ここの実装が実際の実装

infer_exprの
EAdd-EDivについて、
ここで返す値はInt型なので、返り値の第一要素はTyIntである。また、制約があり、その制約は、四則演算の前後のexprが、int型でなければならないことである。
よって、let v1 = infer_expr tenv e1のように評価を行い、その第一要素で制約をかける。(fst(v1),TyInt)。また、その式の中の制約も受け継がなければならないので、unionを用いて受け継ぐ

EEqについて
ここで返す型はbool型なので、返り値の第一要素はTyBoolである。また、制約については、比べるもの同士の型が等しいことである、それに=前後のexpressionの制約をunionする。

EIfについて
まず、e1,e2,e3のexpressionを評価する。
ここで返す型は、e2の返す型であるから、返り値の第一要素は、fst(v2)となる。If文であることに注意すると、e1の評価結果はBool型でならなければならず、また、e2とe3の評価結果の型は同じでなければならないことを制約として加える。

ELetについて
まず、今の環境のもとで、e1の型と制約を求める。
ここでできた環境(newtenv = (e1,fst(v1)) :: tenv)のもとで、e2を評価する。
返り値の第一要素はその評価結果の第一要素であるし、返り値の第二要素は、e1とe2の評価ででてきた制約をunionしたものである。

EFunについて
まず、新たな型変数newvarを導入する。
現在の型環境にe1とnewvarとの対応を付け加える。
そして、そのもとで、e2を評価すれば良い。
全体の型は、関数の形で、(newvar -> e2の評価結果の型)となる。

EAppについて
まず、現在の型環境でそれぞれのexpressionについて型と制約を求める。
次に新たな型変数newvarを導入する。
返り値の第一要素はnewvarであり、制約として、((e1の評価結果の型) = (e2の評価結果の型) -> (newvar))を与える。








let文に対して環境を追加できるようにする作業スタート

まずmain.mlにinitialenvを追加して
それに合わせてprint_envも変更

eval.mlのeval_commandの出力に追加



